{
  "name": "fjs",
  "version": "0.5.2",
  "dependencies": {
    "underscore": "git://github.com/documentcloud/underscore.git#1.4.2"
  },
  "readme": "## FJS: Functional Utils For Javascript\n\nFunctional Utilties for Javascript.\n\n[![Build Status](https://secure.travis-ci.org/idottv/fjs.png)](http://travis-ci.org/idottv/fjs)\n\n### Reasons\n\nSee this talk for motivation and some good examples. http://www.slideshare.net/drboolean/pointfree-functional-programming-in-javascript [Code Samples](https://github.com/DrBoolean/PointfreeJSTalk)\n\nThere are two main concepts this library uses. Currying (or partial application), and Point-free code, or higher-order programming\n\n### Point-Free / Higher-order functions\n\nWe can do some powerful stuff by writing functions that create other functions. \n\n    TODO: add example\n\nTo define a function, we don't always have to actually make a function. Instead, we can rename an existing function. For example: \n\n    TODO: add example\n\n### Currying / Partial Application\n\n\n### Compose\n\n    TODO: add example\n\n## API\n\n#### Curry\n\nAllows you to easily curry functions. This means that if you call the curried version of a function with fewer arguments that it requires, it returns a function to call with the remaining arguments. The function short-circuits if you call it with the correct number of arguments, meaning that it doesn't affect performance unless it has to. \n\nSee: http://en.wikipedia.org/wiki/Currying\n\nThe syntax looks best in coffeescript, because you can just prefix a function definition with curry. \n\n    curry = require('fjs').curry\n\n    # just wrap your function in curry() and it will do the rest\n    add = curry (a, b) -> a + b\n    add2 = add(2)\n\n    assert.equal add(2,3), 5\n    assert.equal add2(3), 5\n    assert.equal add(2)(3), 5\n\n    assert.deepEqual [1,2,3].map(add(2)), [3,4,5]\n\n\nYou can also use `curry` on a whole module, making it easy to work with functions that haven't been declared as curried. It curry any module functions it finds. Since curry doesn't have any effect when the function is called with all arguments, it doens't hurt anything to do this. \n\n    math = curry require('math')\n    add2 = math.add(2)\n\n#### Simple Stuff\n\nWe need some simple functions so we can call object actions as functions instead of doing it with a \".\"\n\n    // get\n    getName = get 'name'\n    getName(obj) == obj.name\n\n    // set\n    setNameIsBob = set 'name', 'bob'\n    setNameIsBob(obj)\n    obj.name = 'bob'\n\n    // call\n    getName = call 'getName'\n    getName(obj) == obj.getName()\n\n    TODO: add example of application on set/call\n    TODO: basics (eq, etc), and why. Example of why it's useful\n\n#### Underscore Functions\n\n[Underscore.js](http://underscorejs.org/) is awesome, but it puts the data first. For example, `underscore.map` is of type: `(list, iterator) ->`. This makes it nearly impossible to do point-free javascript. They're also not curried. For this reason, the following functions are taken from underscore, but they have their data last\n\nTheir types are all the same:\n\n    find(iterator, list)\n\n* find\n* map\n* filter \n* reducep\n* each \n* min \n* max\n\nYou can curry these, for example:\n\n    add2 = (n) -> n + 2\n    add2ToEverything = map add2\n    add2ToEverything [1,2,3]\n\nWe also export the following as-is for convenience\n\n* head/first\n* last\n* tail/rest\n* compose\n\n",
  "readmeFilename": "README.md",
  "_id": "fjs@0.5.2",
  "description": "Functional Utilties for Javascript.",
  "repository": {
    "type": "git",
    "url": "git://github.com/seanhess/fjs"
  }
}